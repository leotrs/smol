{% extends "base.html" %}

{% block title %}Compare - SMOL{% endblock %}

{% block content %}
{% set cospectral_matrices = [] %}
{% for matrix, status in result.spectral_comparison.items() %}
    {% if (status == 'same' or status == '0.0000' or (status is number and status == 0.0)) %}
        {% set _ = cospectral_matrices.append(matrix) %}
    {% endif %}
{% endfor %}

{% set matrix_labels = {'adj': 'adj', 'kirchhoff': 'kir', 'signless': 'sgl', 'lap': 'lap', 'nb': 'nb', 'nbl': 'nbl', 'dist': 'dist'} %}

<hgroup>
    <h1 style="display: flex; justify-content: space-between; align-items: baseline; gap: 1rem;">
        <span>Compare Graphs</span>
        {% if cospectral_matrices|length > 0 %}
        <span style="font-size: 0.5em; font-weight: 500; color: var(--pico-muted-color); white-space: nowrap;">
            cospectral for
            {% for matrix in cospectral_matrices %}
            <span class="tag" style="background: var(--pico-primary); color: white; padding: 0.15rem 0.4rem; border-radius: 3px; font-size: 0.9em; margin-left: 0.25rem;">{{ matrix_labels[matrix] }}</span>
            {% endfor %}
        </span>
        {% else %}
        <span style="font-size: 0.5em; font-weight: 400; color: var(--pico-muted-color);">not cospectral</span>
        {% endif %}
    </h1>
    <p>Comparing {{ result.graphs|length }} graphs side by side.</p>
</hgroup>

<div class="compare-grid">
{% for g in result.graphs %}
    <div class="graph-card">
        <div style="text-align: center; margin-bottom: 0.5rem;">
            <a href="/graph/{{ g.graph6 | urlencode }}"><code>{{ g.graph6 }}</code></a>
        </div>
        <div class="viz-container" style="display: flex; justify-content: center;">
            <div id="viz-{{ loop.index0 }}" class="graph-viz" style="width: 180px; height: 180px;"></div>
            <button class="viz-reset-btn" onclick="resetCompareViz({{ loop.index0 }})" title="Reset view">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
        </div>
    </div>
{% endfor %}
</div>

<h3>Spectra</h3>
{% if result.graphs|length > 1 %}
<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 1.5rem; margin-bottom: 0.75rem;">
    {% for g in result.graphs %}
    <button class="spectrum-pill active" data-graph="{{ loop.index0 }}" onclick="toggleCompareGraphMarkers(this, {{ loop.index0 }})">
        <span class="graph-marker-icon" data-marker="{{ loop.index0 }}"></span>
        <code style="font-size: 0.75rem; margin-left: 0.25rem;">{{ g.graph6 }}</code>
    </button>
    {% endfor %}
</div>
{% endif %}
<div style="display: flex; gap: 3rem; flex-wrap: wrap;">
    <div class="viz-container" style="flex: 1; min-width: 450px;">
        <div id="compare-spectrum-real-plot" style="height: 350px;"></div>
        <button class="viz-reset-btn" onclick="resetCompareSpectrumRealPlot()" title="Reset view">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        </button>
    </div>
    <div class="viz-container" style="flex: 1; min-width: 450px;">
        <div id="compare-spectrum-complex-plot" style="height: 350px;"></div>
        <button class="viz-reset-btn" onclick="resetCompareSpectrumComplexPlot()" title="Reset view">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        </button>
    </div>
</div>

<h3>{% if result.graphs|length == 2 %}Spectral Distance{% else %}Spectral Comparison{% endif %}</h3>
{% if result.distance_matrix %}
{% set matrix_labels = {'adj': 'adj', 'kirchhoff': 'kir', 'signless': 'sgl', 'lap': 'lap', 'nb': 'nb', 'nbl': 'nbl', 'dist': 'dist'} %}
{% set graph_labels = result.graphs | map(attribute='graph6') | list %}
{% set n = graph_labels|length %}

<div class="distance-matrices-container">
    {% for matrix_name, matrix_data in result.distance_matrix.items() %}
    <div class="distance-matrix">
        <h4 class="matrix-label">{{ matrix_labels[matrix_name] }}</h4>
        <div class="matrix-grid" style="grid-template-columns: auto repeat({{ n - 1 }}, 1fr);">
            {# Header row with column labels #}
            <div class="cell empty"></div>
            {% for i in range(1, n) %}
            <div class="cell header col-header">
                <span class="rotated-label">{{ graph_labels[i] }}</span>
            </div>
            {% endfor %}

            {# Data rows #}
            {% for i in range(n - 1) %}
                {# Row label #}
                <div class="cell header row-header">{{ graph_labels[i] }}</div>

                {# Data cells (only upper diagonal) #}
                {% for j in range(1, n) %}
                    {% if j > i %}
                        {% set value = matrix_data[i][j] %}
                        {% set is_mate = (value == 0.0 and value is number) %}
                        {% set is_nan = (value != value) %}
                        <div class="cell data-cell{% if is_mate %} mate-cell{% elif is_nan %} na-cell{% endif %}"
                             {% if not is_nan %}style="background: linear-gradient(to right, var(--cell-color-start), var(--cell-color-end)); --distance: {{ value }};"{% endif %}
                             data-distance="{{ value if not is_nan else 'N/A' }}">
                            {% if is_mate %}
                                <span class="mate-text">mate</span>
                                <span class="mate-value">0.0000</span>
                            {% elif not is_nan %}
                                <span class="distance-value">{{ "%.4f"|format(value) }}</span>
                            {% endif %}
                        </div>
                    {% else %}
                        <div class="cell empty"></div>
                    {% endif %}
                {% endfor %}
            {% endfor %}
        </div>
    </div>
    {% endfor %}
</div>

<div class="distance-legend">
    <div class="legend-bar"></div>
    <div class="legend-labels">
        <span>0</span>
        <span>Distance</span>
        <span id="legend-max">â€”</span>
    </div>
</div>

<script>
// Compute color scale for all distance values
const distanceMatrixData = {{ result.distance_matrix | tojson }};
const allValues = [];
Object.values(distanceMatrixData).forEach(matrix => {
    matrix.forEach((row, i) => {
        row.forEach((val, j) => {
            if (j > i && !isNaN(val)) allValues.push(val);
        });
    });
});

const maxDist = Math.max(...allValues) || 1;
document.getElementById('legend-max').textContent = maxDist.toFixed(2);

// Apply colors to cells based on distance
document.querySelectorAll('.data-cell[data-distance]').forEach(cell => {
    const dist = parseFloat(cell.dataset.distance);
    if (!isNaN(dist)) {
        const ratio = dist / maxDist;
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const startColor = '#14B8A6';  // Teal for low distance
        const endColor = isDark ? '#0f172a' : '#ffffff';  // Dark/white for high distance

        // Interpolate between colors
        cell.style.setProperty('--cell-color-start', startColor);
        cell.style.setProperty('--cell-color-end', endColor);
        cell.style.background = `color-mix(in srgb, ${startColor} ${(1-ratio)*100}%, ${endColor})`;

        // Set text color based on background
        const textColor = ratio > 0.5 ? (isDark ? '#ddd' : '#000') : '#fff';
        cell.style.color = textColor;
    }
});

// Update on theme change
const observer = new MutationObserver(() => {
    document.querySelectorAll('.data-cell[data-distance]').forEach(cell => {
        const dist = parseFloat(cell.dataset.distance);
        if (!isNaN(dist)) {
            const ratio = dist / maxDist;
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const endColor = isDark ? '#0f172a' : '#ffffff';
            const startColor = '#14B8A6';
            cell.style.background = `color-mix(in srgb, ${startColor} ${(1-ratio)*100}%, ${endColor})`;
            const textColor = ratio > 0.5 ? (isDark ? '#ddd' : '#000') : '#fff';
            cell.style.color = textColor;
        }
    });
});
observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
</script>
{% else %}
<p>
    {% for matrix, status in result.spectral_comparison.items() %}
        <strong>{{ matrix }}:</strong>
        {% if status in ('same', 'different') %}
            <span class="badge badge-{{ status }}">{{ status }}</span>
        {% elif status == '0.0000' %}
            <code style="color: var(--pico-primary);">{{ status }}</code>
            <span class="mate-badge">mate</span>
        {% else %}
            <code>{{ status }}</code>
        {% endif %}
        {% if not loop.last %}&nbsp;&nbsp;{% endif %}
    {% endfor %}
</p>
{% endif %}

<script>
const compareVizStates = [];

function resetCompareViz(idx) {
    if (compareVizStates[idx]) {
        compareVizStates[idx].transform.x = 0;
        compareVizStates[idx].transform.y = 0;
        compareVizStates[idx].transform.k = 1;
        compareVizStates[idx].update();
    }
}

function renderGraphs() {
    const graphs = {{ result.graphs | tojson }};
    graphs.forEach((g, idx) => {
        const width = 180, height = 180;
        const nodes = Array.from({length: g.n}, (_, i) => ({id: i}));
        const links = g.edges.map(([s, t]) => ({source: s, target: t}));

        const svg = d3.select("#viz-" + idx)
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab");

        // Container group for panning
        const container = svg.append("g");

        // Viewport pan and zoom
        let transform = {x: 0, y: 0, k: 1};

        function updateTransform() {
            container.attr("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
        }

        // Store for reset button
        compareVizStates[idx] = { transform, update: updateTransform };

        svg.call(d3.drag()
            .on("start", () => svg.style("cursor", "grabbing"))
            .on("drag", (event) => {
                transform.x += event.dx;
                transform.y += event.dy;
                updateTransform();
            })
            .on("end", () => svg.style("cursor", "grab")));

        svg.on("wheel", (event) => {
            event.preventDefault();
            const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
            const newK = Math.max(0.2, Math.min(5, transform.k * scaleFactor));

            // Get mouse position relative to SVG
            const [mx, my] = d3.pointer(event, svg.node());

            // Zoom centered on mouse position
            transform.x = mx - (mx - transform.x) * (newK / transform.k);
            transform.y = my - (my - transform.y) * (newK / transform.k);
            transform.k = newK;

            updateTransform();
        });

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(35))
            .force("charge", d3.forceManyBody().strength(-80))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const style = getComputedStyle(document.documentElement);
        const nodeColor = style.getPropertyValue('--graph-node-color').trim();
        const edgeColor = style.getPropertyValue('--graph-edge-color').trim();

        const link = container.append("g")
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("stroke", edgeColor)
            .attr("stroke-width", 2);

        const node = container.append("g")
            .selectAll("circle")
            .data(nodes)
            .join("circle")
            .attr("r", 5)
            .attr("fill", nodeColor)
            .style("cursor", "pointer")
            .call(d3.drag()
                .on("start", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                    event.sourceEvent.stopPropagation();
                })
                .on("drag", (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on("end", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }));

        const padding = 8;
        simulation.on("tick", () => {
            // Constrain nodes to viewport
            nodes.forEach(d => {
                d.x = Math.max(padding, Math.min(width - padding, d.x));
                d.y = Math.max(padding, Math.min(height - padding, d.y));
            });

            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        });
    });
}

let compareSpectrumRealPlotState = null;
let compareSpectrumComplexPlotState = null;

function renderCompareSpectrumRealPlot() {
    const graphs = {{ result.graphs | tojson }};
    const container = document.getElementById('compare-spectrum-real-plot');
    if (!container || graphs.length === 0) return;

    container.innerHTML = '';

    const graphsSpectra = graphs.map((g, idx) => ({
        graphIndex: idx,
        graph6: g.graph6,
        spectra: {
            adj: g.spectra.adj_eigenvalues.map(re => ({re, im: 0})),
            kirchhoff: (g.spectra.kirchhoff_eigenvalues || []).map(re => ({re, im: 0})),
            signless: (g.spectra.signless_eigenvalues || []).map(re => ({re, im: 0})),
            lap: g.spectra.lap_eigenvalues.map(re => ({re, im: 0})),
            dist: (g.spectra.dist_eigenvalues || []).map(re => ({re, im: 0}))
        }
    }));

    const width = container.clientWidth || 500;
    const height = 350;
    const margin = {top: 10, right: 20, bottom: 50, left: 100};
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;

    const matrices = ['adj', 'kirchhoff', 'signless', 'lap', 'dist'];
    const laneHeight = plotHeight / matrices.length;

    // Collect all real eigenvalues to determine x-axis domain
    const allReals = [];
    graphsSpectra.forEach(gs => {
        matrices.forEach(matrix => {
            gs.spectra[matrix].forEach(p => allReals.push(p.re));
        });
    });

    const reExtent = d3.extent(allReals);
    const rePadding = (reExtent[1] - reExtent[0]) * 0.1 || 0.5;

    const xScale = d3.scaleLinear()
        .domain([reExtent[0] - rePadding, reExtent[1] + rePadding])
        .range([0, plotWidth]);

    const svg = d3.select('#compare-spectrum-real-plot')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('cursor', 'grab');

    svg.append('defs').append('clipPath')
        .attr('id', 'real-plot-clip')
        .append('rect')
        .attr('width', plotWidth)
        .attr('height', plotHeight);

    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const plotArea = g.append('g')
        .attr('clip-path', 'url(#real-plot-clip)');

    const content = plotArea.append('g');

    let transform = {x: 0, y: 0, k: 1};
    const baseRadius = 4;

    function updatePlotTransform() {
        content.attr('transform', `translate(${transform.x},0) scale(${transform.k},1)`);
        content.selectAll('.eigenvalue-dot').attr('r', baseRadius / transform.k);
        content.selectAll('.eigenvalue-symbol').attr('d', d => d3.symbol().type(d.symbolType).size(50 / (transform.k * transform.k)));
    }

    compareSpectrumRealPlotState = { transform, update: updatePlotTransform };

    svg.call(d3.drag()
        .on('start', () => svg.style('cursor', 'grabbing'))
        .on('drag', (event) => {
            transform.x += event.dx;
            updatePlotTransform();
        })
        .on('end', () => svg.style('cursor', 'grab')));

    svg.on('wheel', (event) => {
        event.preventDefault();
        const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
        const newK = Math.max(0.2, Math.min(5, transform.k * scaleFactor));
        const [mx] = d3.pointer(event, plotArea.node());
        transform.x = mx - (mx - transform.x) * (newK / transform.k);
        transform.k = newK;
        updatePlotTransform();
    });

    const tooltip = d3.select('body').append('div')
        .attr('class', 'spectrum-tooltip')
        .style('position', 'absolute')
        .style('visibility', 'hidden')
        .style('background', 'var(--pico-card-background-color)')
        .style('border', '1px solid var(--pico-muted-border-color)')
        .style('border-radius', '4px')
        .style('padding', '4px 8px')
        .style('font-size', '12px')
        .style('pointer-events', 'none')
        .style('z-index', '1000');

    const style = getComputedStyle(document.documentElement);
    const axisColor = style.getPropertyValue('--pico-muted-color').trim() || '#666';
    const borderColor = style.getPropertyValue('--pico-muted-border-color').trim() || '#ddd';

    const xAxis = g.append('g')
        .attr('transform', `translate(0,${plotHeight})`)
        .call(d3.axisBottom(xScale).ticks(6));
    xAxis.selectAll('text').attr('fill', axisColor).attr('stroke', 'none');
    xAxis.selectAll('line, path').attr('stroke', borderColor);

    g.append('text')
        .attr('x', plotWidth / 2)
        .attr('y', plotHeight + 40)
        .attr('text-anchor', 'middle')
        .attr('fill', axisColor)
        .attr('font-size', '13px')
        .text('Eigenvalue');

    const colors = {
        adj: style.getPropertyValue('--spectrum-adj').trim(),
        kirchhoff: style.getPropertyValue('--spectrum-kirchhoff').trim() || '#8B4513',
        signless: style.getPropertyValue('--spectrum-signless').trim() || '#F97316',
        lap: style.getPropertyValue('--spectrum-lap').trim(),
        dist: style.getPropertyValue('--spectrum-dist').trim() || '#9333EA'
    };

    const labels = {adj: 'adj', kirchhoff: 'kir', signless: 'sgl', lap: 'lap', dist: 'dist'};

    const markerShapes = [
        { name: 'circle', type: null },
        { name: 'square', type: null },
        { name: 'triangle', type: d3.symbolTriangle },
        { name: 'diamond', type: d3.symbolDiamond },
        { name: 'cross', type: d3.symbolCross },
        { name: 'star', type: d3.symbolStar }
    ];

    // Draw lanes and labels
    matrices.forEach((matrix, i) => {
        const laneY = i * laneHeight;

        // Label
        g.append('text')
            .attr('x', -15)
            .attr('y', laneY + laneHeight / 2)
            .attr('text-anchor', 'end')
            .attr('dominant-baseline', 'middle')
            .attr('fill', colors[matrix])
            .attr('font-size', '13px')
            .attr('font-weight', '600')
            .text(labels[matrix]);

        // Draw horizontal axis lines for each graph at their respective heights
        const numGraphs = graphsSpectra.length;
        const tickValues = xScale.ticks(6);
        for (let graphIdx = 0; graphIdx < numGraphs; graphIdx++) {
            const yPos = laneY + laneHeight * ((graphIdx + 1) / (numGraphs + 1));
            content.append('line')
                .attr('x1', 0)
                .attr('x2', plotWidth)
                .attr('y1', yPos)
                .attr('y2', yPos)
                .attr('stroke', borderColor)
                .attr('stroke-opacity', 0.4)
                .attr('stroke-width', 1);

            // Add tick marks at each tick position
            tickValues.forEach(tickValue => {
                const tickX = xScale(tickValue);
                content.append('line')
                    .attr('x1', tickX)
                    .attr('x2', tickX)
                    .attr('y1', yPos - 3)
                    .attr('y2', yPos + 3)
                    .attr('stroke', borderColor)
                    .attr('stroke-opacity', 0.4)
                    .attr('stroke-width', 1);
            });
        }

        // Draw eigenvalues for each graph at different heights within the lane
        graphsSpectra.forEach((gs, graphIdx) => {
            const markerInfo = markerShapes[graphIdx % markerShapes.length];
            const points = gs.spectra[matrix];

            // Distribute graphs vertically within the lane
            const numGraphs = graphsSpectra.length;
            const yPos = laneY + laneHeight * ((graphIdx + 1) / (numGraphs + 1));

            if (markerInfo.name === 'circle') {
                content.append('g')
                    .attr('class', `spectrum-points spectrum-${matrix} graph-${graphIdx}`)
                    .selectAll('circle')
                    .data(points)
                    .join('circle')
                    .attr('class', 'eigenvalue-dot')
                    .attr('cx', d => xScale(d.re))
                    .attr('cy', yPos)
                    .attr('r', baseRadius)
                    .attr('fill', colors[matrix])
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', (event, d) => {
                        tooltip.style('visibility', 'visible')
                            .html(`<strong>${labels[matrix]}:</strong> ${d.re.toFixed(4)}<br/><code style="font-size:10px;">${gs.graph6}</code>`);
                        d3.select(event.target).attr('r', 6 / transform.k).attr('opacity', 1);
                    })
                    .on('mousemove', (event) => {
                        tooltip.style('top', (event.pageY - 10) + 'px').style('left', (event.pageX + 10) + 'px');
                    })
                    .on('mouseout', (event) => {
                        tooltip.style('visibility', 'hidden');
                        d3.select(event.target).attr('r', baseRadius / transform.k).attr('opacity', 0.7);
                    });
            } else if (markerInfo.name === 'square') {
                content.append('g')
                    .attr('class', `spectrum-points spectrum-${matrix} graph-${graphIdx}`)
                    .selectAll('rect')
                    .data(points)
                    .join('rect')
                    .attr('class', 'eigenvalue-dot')
                    .attr('x', d => xScale(d.re) - baseRadius)
                    .attr('y', yPos - baseRadius)
                    .attr('width', baseRadius * 2)
                    .attr('height', baseRadius * 2)
                    .attr('fill', colors[matrix])
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', (event, d) => {
                        tooltip.style('visibility', 'visible')
                            .html(`<strong>${labels[matrix]}:</strong> ${d.re.toFixed(4)}<br/><code style="font-size:10px;">${gs.graph6}</code>`);
                        d3.select(event.target).attr('width', 12 / transform.k).attr('height', 12 / transform.k)
                            .attr('x', d => xScale(d.re) - 6 / transform.k)
                            .attr('y', yPos - 6 / transform.k)
                            .attr('opacity', 1);
                    })
                    .on('mousemove', (event) => {
                        tooltip.style('top', (event.pageY - 10) + 'px').style('left', (event.pageX + 10) + 'px');
                    })
                    .on('mouseout', (event, d) => {
                        tooltip.style('visibility', 'hidden');
                        d3.select(event.target)
                            .attr('width', baseRadius * 2 / transform.k)
                            .attr('height', baseRadius * 2 / transform.k)
                            .attr('x', xScale(d.re) - baseRadius / transform.k)
                            .attr('y', yPos - baseRadius / transform.k)
                            .attr('opacity', 0.7);
                    });
            } else {
                content.append('g')
                    .attr('class', `spectrum-points spectrum-${matrix} graph-${graphIdx}`)
                    .selectAll('path')
                    .data(points.map(p => ({...p, symbolType: markerInfo.type})))
                    .join('path')
                    .attr('class', 'eigenvalue-symbol')
                    .attr('d', d3.symbol().type(markerInfo.type).size(50))
                    .attr('transform', d => `translate(${xScale(d.re)},${yPos})`)
                    .attr('fill', colors[matrix])
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', (event, d) => {
                        tooltip.style('visibility', 'visible')
                            .html(`<strong>${labels[matrix]}:</strong> ${d.re.toFixed(4)}<br/><code style="font-size:10px;">${gs.graph6}</code>`);
                        d3.select(event.target).attr('d', d3.symbol().type(markerInfo.type).size(100 / (transform.k * transform.k)))
                            .attr('opacity', 1);
                    })
                    .on('mousemove', (event) => {
                        tooltip.style('top', (event.pageY - 10) + 'px').style('left', (event.pageX + 10) + 'px');
                    })
                    .on('mouseout', (event) => {
                        tooltip.style('visibility', 'hidden');
                        d3.select(event.target).attr('d', d3.symbol().type(markerInfo.type).size(50 / (transform.k * transform.k)))
                            .attr('opacity', 0.7);
                    });
            }
        });
    });

    return () => tooltip.remove();
}

function renderCompareSpectrumComplexPlot() {
    const graphs = {{ result.graphs | tojson }};
    const container = document.getElementById('compare-spectrum-complex-plot');
    if (!container || graphs.length === 0) return;

    container.innerHTML = '';

    // Only complex eigenvalue matrices
    const graphsSpectra = graphs.map((g, idx) => ({
        graphIndex: idx,
        graph6: g.graph6,
        spectra: {
            nb: g.spectra.nb_eigenvalues_re.map((re, i) => ({re, im: g.spectra.nb_eigenvalues_im[i]})),
            nbl: g.spectra.nbl_eigenvalues_re.map((re, i) => ({re, im: g.spectra.nbl_eigenvalues_im[i]}))
        }
    }));

    const width = container.clientWidth || 500;
    const height = 350;
    const margin = {top: 20, right: 20, bottom: 50, left: 65};
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;

    // Mirror complex eigenvalues to show conjugate pairs
    function withConjugates(points) {
        const result = [];
        points.forEach(p => {
            result.push(p);
            if (Math.abs(p.im) > 1e-10) {
                result.push({re: p.re, im: -p.im});
            }
        });
        return result;
    }

    // Prepare plot data with conjugates (only complex matrices)
    const plotData = graphsSpectra.map(gs => ({
        ...gs,
        plotSpectra: {
            nb: withConjugates(gs.spectra.nb),
            nbl: withConjugates(gs.spectra.nbl)
        }
    }));

    // Collect all points for domain calculation
    const allPoints = [];
    plotData.forEach(gs => {
        Object.values(gs.plotSpectra).forEach(points => {
            allPoints.push(...points);
        });
    });

    const reExtent = d3.extent(allPoints, d => d.re);
    let imExtent = d3.extent(allPoints, d => d.im);

    // Make y-axis symmetric around 0
    const imMax = Math.max(Math.abs(imExtent[0]), Math.abs(imExtent[1]));
    imExtent = [-imMax, imMax];

    const rePadding = (reExtent[1] - reExtent[0]) * 0.1 || 0.5;
    const imPadding = imMax * 0.1 || 0.5;

    // Calculate data ranges with padding
    const xDataRange = (reExtent[1] - reExtent[0]) + 2 * rePadding;
    const yDataRange = 2 * (imMax + imPadding);

    // Force 1:1 aspect ratio by using the same scale for both axes
    const xPixelsPerUnit = plotWidth / xDataRange;
    const yPixelsPerUnit = plotHeight / yDataRange;
    const pixelsPerUnit = Math.min(xPixelsPerUnit, yPixelsPerUnit);

    // Center the data in the available space
    const xCenter = (reExtent[0] + reExtent[1]) / 2;
    const yCenter = 0;
    const xHalfRange = (plotWidth / pixelsPerUnit) / 2;
    const yHalfRange = (plotHeight / pixelsPerUnit) / 2;

    const xScale = d3.scaleLinear()
        .domain([xCenter - xHalfRange, xCenter + xHalfRange])
        .range([0, plotWidth]);

    const yScale = d3.scaleLinear()
        .domain([yCenter - yHalfRange, yCenter + yHalfRange])
        .range([plotHeight, 0]);

    const svg = d3.select('#compare-spectrum-complex-plot')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('cursor', 'grab');

    // Clip path to contain points within plot area
    svg.append('defs').append('clipPath')
        .attr('id', 'complex-plot-clip')
        .append('rect')
        .attr('width', plotWidth)
        .attr('height', plotHeight);

    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Container for pannable/zoomable content
    const plotArea = g.append('g')
        .attr('clip-path', 'url(#complex-plot-clip)');

    const content = plotArea.append('g');

    // Viewport pan and zoom
    let transform = {x: 0, y: 0, k: 1};
    const baseRadius = 4;

    function updatePlotTransform() {
        content.attr('transform', `translate(${transform.x},${transform.y}) scale(${transform.k})`);
        // Keep eigenvalue dots at constant visual size by scaling radius inversely
        content.selectAll('.eigenvalue-dot').attr('r', baseRadius / transform.k);
        // Keep symbol sizes constant
        content.selectAll('.eigenvalue-symbol').attr('d', d3.symbol().type(d => d.symbolType).size(50 / (transform.k * transform.k)));
    }

    // Store for reset button
    compareSpectrumComplexPlotState = { transform, update: updatePlotTransform };

    svg.call(d3.drag()
        .on('start', () => svg.style('cursor', 'grabbing'))
        .on('drag', (event) => {
            transform.x += event.dx;
            transform.y += event.dy;
            updatePlotTransform();
        })
        .on('end', () => svg.style('cursor', 'grab')));

    svg.on('wheel', (event) => {
        event.preventDefault();
        const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
        const newK = Math.max(0.2, Math.min(5, transform.k * scaleFactor));

        // Get mouse position relative to plot area
        const [mx, my] = d3.pointer(event, plotArea.node());

        // Zoom centered on mouse position
        transform.x = mx - (mx - transform.x) * (newK / transform.k);
        transform.y = my - (my - transform.y) * (newK / transform.k);
        transform.k = newK;

        updatePlotTransform();
    });

    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'spectrum-tooltip')
        .style('position', 'absolute')
        .style('visibility', 'hidden')
        .style('background', 'var(--pico-card-background-color)')
        .style('border', '1px solid var(--pico-muted-border-color)')
        .style('border-radius', '4px')
        .style('padding', '4px 8px')
        .style('font-size', '12px')
        .style('pointer-events', 'none')
        .style('z-index', '1000');

    const style = getComputedStyle(document.documentElement);
    const axisColor = style.getPropertyValue('--pico-muted-color').trim() || '#666';
    const borderColor = style.getPropertyValue('--pico-muted-border-color').trim() || '#ddd';

    // X axis
    const xAxis = g.append('g')
        .attr('transform', `translate(0,${plotHeight})`)
        .call(d3.axisBottom(xScale).ticks(6));
    xAxis.selectAll('text').attr('fill', axisColor).attr('stroke', 'none');
    xAxis.selectAll('line, path').attr('stroke', borderColor);

    // Y axis
    const yAxis = g.append('g')
        .call(d3.axisLeft(yScale).ticks(6));
    yAxis.selectAll('text').attr('fill', axisColor).attr('stroke', 'none');
    yAxis.selectAll('line, path').attr('stroke', borderColor);

    // Axis labels
    g.append('text')
        .attr('x', plotWidth / 2)
        .attr('y', plotHeight + 40)
        .attr('text-anchor', 'middle')
        .attr('fill', axisColor)
        .attr('font-size', '13px')
        .text('Re');

    g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -plotHeight / 2)
        .attr('y', -45)
        .attr('text-anchor', 'middle')
        .attr('fill', axisColor)
        .attr('font-size', '13px')
        .text('Im');

    // Zero lines (in content so they pan)
    if (xScale.domain()[0] < 0 && xScale.domain()[1] > 0) {
        content.append('line')
            .attr('x1', xScale(0))
            .attr('x2', xScale(0))
            .attr('y1', 0)
            .attr('y2', plotHeight)
            .attr('stroke', axisColor)
            .attr('stroke-opacity', 0.3)
            .attr('stroke-dasharray', '4,4');
    }
    if (yScale.domain()[0] < 0 && yScale.domain()[1] > 0) {
        content.append('line')
            .attr('x1', 0)
            .attr('x2', plotWidth)
            .attr('y1', yScale(0))
            .attr('y2', yScale(0))
            .attr('stroke', axisColor)
            .attr('stroke-opacity', 0.3)
            .attr('stroke-dasharray', '4,4');
    }

    const colors = {
        nb: style.getPropertyValue('--spectrum-nb').trim(),
        nbl: style.getPropertyValue('--spectrum-nbl').trim()
    };

    const labels = {nb: 'NB', nbl: 'NBL'};

    // Draw unit circle (in content so it pans, but scales with zoom)
    const circleRadius = Math.abs(xScale(1) - xScale(0));
    content.append('circle')
        .attr('class', 'unit-circle')
        .attr('cx', xScale(0))
        .attr('cy', yScale(0))
        .attr('r', circleRadius)
        .attr('fill', 'none')
        .attr('stroke', axisColor)
        .attr('stroke-opacity', 0.2)
        .attr('stroke-dasharray', '4,4');

    // Format eigenvalue for tooltip
    function formatEig(d) {
        const re = d.re.toFixed(4);
        const im = d.im.toFixed(4);
        if (Math.abs(d.im) < 1e-10) return re;
        const sign = d.im >= 0 ? '+' : '';
        return `${re}${sign}${im}i`;
    }

    // Different marker shapes for different graphs
    const markerShapes = [
        { name: 'circle', type: null },
        { name: 'square', type: null },
        { name: 'triangle', type: d3.symbolTriangle },
        { name: 'diamond', type: d3.symbolDiamond },
        { name: 'cross', type: d3.symbolCross },
        { name: 'star', type: d3.symbolStar }
    ];

    // Draw points for each matrix type and graph (only complex matrices)
    ['nb', 'nbl'].forEach(matrix => {
        plotData.forEach((gs, graphIdx) => {
            const markerInfo = markerShapes[graphIdx % markerShapes.length];
            const points = gs.plotSpectra[matrix];

            if (markerInfo.name === 'circle') {
                content.append('g')
                    .attr('class', `spectrum-points spectrum-${matrix} graph-${graphIdx}`)
                    .selectAll('circle')
                    .data(points)
                    .join('circle')
                    .attr('class', 'eigenvalue-dot')
                    .attr('cx', d => xScale(d.re))
                    .attr('cy', d => yScale(d.im))
                    .attr('r', baseRadius)
                    .attr('fill', colors[matrix])
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', (event, d) => {
                        tooltip.style('visibility', 'visible')
                            .html(`<strong>${labels[matrix]}:</strong> ${formatEig(d)}<br/><code style="font-size:10px;">${gs.graph6}</code>`);
                        d3.select(event.target).attr('r', 6 / transform.k).attr('opacity', 1);
                    })
                    .on('mousemove', (event) => {
                        tooltip.style('top', (event.pageY - 10) + 'px')
                            .style('left', (event.pageX + 10) + 'px');
                    })
                    .on('mouseout', (event) => {
                        tooltip.style('visibility', 'hidden');
                        d3.select(event.target).attr('r', baseRadius / transform.k).attr('opacity', 0.7);
                    });
            } else if (markerInfo.name === 'square') {
                content.append('g')
                    .attr('class', `spectrum-points spectrum-${matrix} graph-${graphIdx}`)
                    .selectAll('rect')
                    .data(points)
                    .join('rect')
                    .attr('class', 'eigenvalue-dot')
                    .attr('x', d => xScale(d.re) - baseRadius)
                    .attr('y', d => yScale(d.im) - baseRadius)
                    .attr('width', baseRadius * 2)
                    .attr('height', baseRadius * 2)
                    .attr('fill', colors[matrix])
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', (event, d) => {
                        tooltip.style('visibility', 'visible')
                            .html(`<strong>${labels[matrix]}:</strong> ${formatEig(d)}<br/><code style="font-size:10px;">${gs.graph6}</code>`);
                        d3.select(event.target).attr('width', 12 / transform.k).attr('height', 12 / transform.k)
                            .attr('x', d => xScale(d.re) - 6 / transform.k)
                            .attr('y', d => yScale(d.im) - 6 / transform.k)
                            .attr('opacity', 1);
                    })
                    .on('mousemove', (event) => {
                        tooltip.style('top', (event.pageY - 10) + 'px')
                            .style('left', (event.pageX + 10) + 'px');
                    })
                    .on('mouseout', (event, d) => {
                        tooltip.style('visibility', 'hidden');
                        d3.select(event.target)
                            .attr('width', baseRadius * 2 / transform.k)
                            .attr('height', baseRadius * 2 / transform.k)
                            .attr('x', xScale(d.re) - baseRadius / transform.k)
                            .attr('y', yScale(d.im) - baseRadius / transform.k)
                            .attr('opacity', 0.7);
                    });
            } else {
                content.append('g')
                    .attr('class', `spectrum-points spectrum-${matrix} graph-${graphIdx}`)
                    .selectAll('path')
                    .data(points.map(p => ({...p, symbolType: markerInfo.type})))
                    .join('path')
                    .attr('class', 'eigenvalue-symbol')
                    .attr('d', d3.symbol().type(markerInfo.type).size(50))
                    .attr('transform', d => `translate(${xScale(d.re)},${yScale(d.im)})`)
                    .attr('fill', colors[matrix])
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', (event, d) => {
                        tooltip.style('visibility', 'visible')
                            .html(`<strong>${labels[matrix]}:</strong> ${formatEig(d)}<br/><code style="font-size:10px;">${gs.graph6}</code>`);
                        d3.select(event.target).attr('d', d3.symbol().type(markerInfo.type).size(100 / (transform.k * transform.k)))
                            .attr('opacity', 1);
                    })
                    .on('mousemove', (event) => {
                        tooltip.style('top', (event.pageY - 10) + 'px')
                            .style('left', (event.pageX + 10) + 'px');
                    })
                    .on('mouseout', (event) => {
                        tooltip.style('visibility', 'hidden');
                        d3.select(event.target).attr('d', d3.symbol().type(markerInfo.type).size(50 / (transform.k * transform.k)))
                            .attr('opacity', 0.7);
                    });
            }
        });
    });

    // Initialize marker icons in legend
    if (graphs.length > 1) {
        document.querySelectorAll('.graph-marker-icon').forEach((icon, idx) => {
            const markerInfo = markerShapes[idx % markerShapes.length];
            const svg = d3.create('svg')
                .attr('width', 12)
                .attr('height', 12)
                .style('display', 'inline-block')
                .style('vertical-align', 'middle');

            if (markerInfo.name === 'circle') {
                svg.append('circle')
                    .attr('cx', 6)
                    .attr('cy', 6)
                    .attr('r', 4)
                    .attr('fill', axisColor);
            } else if (markerInfo.name === 'square') {
                svg.append('rect')
                    .attr('x', 2)
                    .attr('y', 2)
                    .attr('width', 8)
                    .attr('height', 8)
                    .attr('fill', axisColor);
            } else {
                svg.append('path')
                    .attr('d', d3.symbol().type(markerInfo.type).size(50))
                    .attr('transform', 'translate(6,6)')
                    .attr('fill', axisColor);
            }

            icon.appendChild(svg.node());
        });
    }

    // Add legend in top-right corner
    const legend = g.append('g')
        .attr('class', 'spectrum-legend')
        .attr('transform', `translate(${plotWidth - 10}, 10)`);

    const legendItems = [
        { label: 'nb', color: colors.nb },
        { label: 'nbl', color: colors.nbl }
    ];

    legendItems.forEach((item, i) => {
        const legendRow = legend.append('g')
            .attr('transform', `translate(0, ${i * 18})`);

        legendRow.append('text')
            .attr('text-anchor', 'end')
            .attr('fill', item.color)
            .attr('font-size', '13px')
            .attr('font-weight', '600')
            .text(item.label);
    });

    // Clean up tooltip when plot is re-rendered
    return () => tooltip.remove();
}

function toggleCompareGraphMarkers(btn, graphIdx) {
    btn.classList.toggle('active');
    const visible = btn.classList.contains('active');
    d3.selectAll(`.graph-${graphIdx}`)
        .style('display', visible ? null : 'none');
}

function resetCompareSpectrumRealPlot() {
    if (compareSpectrumRealPlotState) {
        compareSpectrumRealPlotState.transform.x = 0;
        compareSpectrumRealPlotState.transform.y = 0;
        compareSpectrumRealPlotState.transform.k = 1;
        compareSpectrumRealPlotState.update();
    }
}

function resetCompareSpectrumComplexPlot() {
    if (compareSpectrumComplexPlotState) {
        compareSpectrumComplexPlotState.transform.x = 0;
        compareSpectrumComplexPlotState.transform.y = 0;
        compareSpectrumComplexPlotState.transform.k = 1;
        compareSpectrumComplexPlotState.update();
    }
}
</script>
<script src="https://d3js.org/d3.v7.min.js" onload="renderGraphs(); renderCompareSpectrumRealPlot(); renderCompareSpectrumComplexPlot();"></script>

<h3>Properties</h3>
<div class="table-wrapper">
<table>
    <thead>
        <tr>
            <th>Property</th>
            {% for g in result.graphs %}
            <th><a href="/graph/{{ g.graph6 | urlencode }}"><code>{{ g.graph6 }}</code></a></th>
            {% endfor %}
        </tr>
    </thead>
    <tbody>
        <tr{% if prop_diffs.n %} class="row-diff"{% endif %}>
            <td>Vertices</td>
            {% for g in result.graphs %}<td>{{ g.n }}</td>{% endfor %}
        </tr>
        <tr{% if prop_diffs.m %} class="row-diff"{% endif %}>
            <td>Edges</td>
            {% for g in result.graphs %}<td>{{ g.m }}</td>{% endfor %}
        </tr>
        <tr{% if prop_diffs.tags %} class="row-diff"{% endif %}>
            <td>Tags</td>
            {% for g in result.graphs %}
            {% set all_tags = g.tags | default([]) | list %}
            {% if g.properties.is_bipartite and 'bipartite' not in all_tags %}{% set _ = all_tags.append('bipartite') %}{% endif %}
            {% if g.properties.is_planar and 'planar' not in all_tags %}{% set _ = all_tags.append('planar') %}{% endif %}
            {% if g.properties.is_regular and 'regular' not in all_tags %}{% set _ = all_tags.append('regular') %}{% endif %}
            <td>{% if all_tags %}{% for tag in all_tags | sort %}<span class="tag tag-sm">{{ tag }}</span>{% endfor %}{% else %}-{% endif %}</td>
            {% endfor %}
        </tr>
        <tr{% if prop_diffs.diameter %} class="row-diff"{% endif %}>
            <td>Diameter</td>
            {% for g in result.graphs %}<td>{{ g.properties.diameter if g.properties.diameter else "-" }}</td>{% endfor %}
        </tr>
        <tr{% if prop_diffs.girth %} class="row-diff"{% endif %}>
            <td>Girth</td>
            {% for g in result.graphs %}<td>{{ g.properties.girth if g.properties.girth else "-" }}</td>{% endfor %}
        </tr>
        <tr{% if prop_diffs.triangle_count %} class="row-diff"{% endif %}>
            <td>Triangles</td>
            {% for g in result.graphs %}<td>{{ g.properties.triangle_count }}</td>{% endfor %}
        </tr>
        {% if result.graphs[0].properties.clique_number is not none %}
        <tr{% if prop_diffs.clique_number %} class="row-diff"{% endif %}>
            <td>Clique number</td>
            {% for g in result.graphs %}<td>{{ g.properties.clique_number if g.properties.clique_number else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
        {% if result.graphs[0].properties.chromatic_number is not none %}
        <tr{% if prop_diffs.chromatic_number %} class="row-diff"{% endif %}>
            <td>Chromatic number</td>
            {% for g in result.graphs %}<td>{{ g.properties.chromatic_number if g.properties.chromatic_number else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
        {% if result.graphs[0].properties.algebraic_connectivity is not none %}
        <tr{% if prop_diffs.algebraic_connectivity %} class="row-diff"{% endif %}>
            <td>Algebraic connectivity</td>
            {% for g in result.graphs %}<td>{{ "%.4f"|format(g.properties.algebraic_connectivity) if g.properties.algebraic_connectivity is not none else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
        {% if result.graphs[0].properties.global_clustering is not none %}
        <tr{% if prop_diffs.global_clustering %} class="row-diff"{% endif %}>
            <td>Global clustering</td>
            {% for g in result.graphs %}<td>{{ "%.4f"|format(g.properties.global_clustering) if g.properties.global_clustering is not none else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
        {% if result.graphs[0].properties.avg_local_clustering is not none %}
        <tr{% if prop_diffs.avg_local_clustering %} class="row-diff"{% endif %}>
            <td>Avg local clustering</td>
            {% for g in result.graphs %}<td>{{ "%.4f"|format(g.properties.avg_local_clustering) if g.properties.avg_local_clustering is not none else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
        {% if result.graphs[0].properties.avg_path_length is not none %}
        <tr{% if prop_diffs.avg_path_length %} class="row-diff"{% endif %}>
            <td>Avg path length</td>
            {% for g in result.graphs %}<td>{{ "%.4f"|format(g.properties.avg_path_length) if g.properties.avg_path_length is not none else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
        {% if result.graphs[0].properties.assortativity is not none %}
        <tr{% if prop_diffs.assortativity %} class="row-diff"{% endif %}>
            <td>Degree assortativity</td>
            {% for g in result.graphs %}<td>{{ "%.4f"|format(g.properties.assortativity) if g.properties.assortativity is not none else "-" }}</td>{% endfor %}
        </tr>
        {% endif %}
    </tbody>
</table>
</div>

<style>
    /* Distance matrix grid layout */
    .distance-matrices-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 3rem 4rem;
        margin: 2rem 0;
    }

    .distance-matrix {
        min-width: 0;
    }

    .distance-matrix .matrix-label {
        margin: 0 0 0.75rem 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--pico-color);
    }

    .matrix-grid {
        display: grid;
        gap: 0;
        width: fit-content;
        max-width: 100%;
        border: 1px solid var(--pico-muted-border-color);
    }

    .matrix-grid .cell {
        background: var(--pico-background-color);
        min-height: 50px;
        min-width: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        font-family: monospace;
        position: relative;
        overflow: hidden;
    }

    .matrix-grid .cell.empty {
        background: transparent;
    }

    .matrix-grid .cell.header {
        font-weight: 500;
        color: var(--pico-muted-color);
        font-size: 0.7rem;
    }

    .matrix-grid .cell.col-header {
        padding-top: 2.5rem;
        align-items: flex-start;
    }

    .matrix-grid .rotated-label {
        transform: rotate(-35deg);
        transform-origin: left bottom;
        white-space: nowrap;
        font-size: 0.7rem;
        position: absolute;
        left: 0.5rem;
        bottom: 0.25rem;
    }

    .matrix-grid .cell.row-header {
        padding-right: 0.5rem;
        justify-content: flex-end;
    }

    .matrix-grid .cell.data-cell {
        flex-direction: column;
        gap: 0.15rem;
        padding: 0.25rem;
    }

    .matrix-grid .cell.na-cell {
        background: var(--pico-muted-border-color);
        opacity: 0.3;
    }

    .matrix-grid .mate-text {
        font-weight: 600;
        font-size: 0.8rem;
    }

    .matrix-grid .mate-value {
        font-size: 0.65rem;
    }

    .matrix-grid .distance-value {
        font-size: 0.75rem;
    }

    @media (max-width: 768px) {
        .distance-matrices-container {
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        .matrix-grid .cell {
            min-height: 35px;
            min-width: 35px;
            height: 38px;
            font-size: 0.55rem;
        }

        .matrix-grid .rotated-label {
            font-size: 0.5rem;
        }
    }

    .mate-badge {
        display: inline-block;
        margin-left: 0.5rem;
        padding: 0.1rem 0.4rem;
        background: var(--pico-primary);
        color: white;
        font-size: 0.65rem;
        font-weight: 600;
        text-transform: uppercase;
        border-radius: 3px;
        vertical-align: middle;
    }

    .distance-legend {
        margin: 2rem auto 1rem;
        max-width: 400px;
    }

    .legend-bar {
        height: 20px;
        background: linear-gradient(to right, #14B8A6, var(--pico-background-color));
        border-radius: 4px;
        border: 1px solid var(--pico-muted-border-color);
        margin-bottom: 0.5rem;
    }

    .legend-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.85rem;
        color: var(--pico-muted-color);
    }

    .legend-labels span:nth-child(2) {
        font-weight: 500;
    }
</style>

{% if result.graphs|length == 2 and mechanisms and mechanisms.get('0_1') %}
{% set matrix_labels = {'adj': 'Adjacency', 'kirchhoff': 'Kirchhoff Laplacian', 'signless': 'Signless Laplacian', 'lap': 'Normalized Laplacian', 'nb': 'Non-Backtracking', 'nbl': 'Non-Backtracking Laplacian'} %}
{% set mech_names = {'gm': 'GM Switching'} %}

{% for matrix_type, mechanism_list in mechanisms['0_1'].items() %}
{% if mechanism_list|length > 0 %}
<h3 style="margin-top: 3rem;">Known Mechanisms for {{ matrix_labels[matrix_type] }}</h3>

{% for mech in mechanism_list %}
<div style="background: var(--pico-card-background-color); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--pico-muted-border-color); margin-bottom: 1.5rem;">
    <h4 style="margin: 0 0 1.5rem 0; font-size: 1.1rem;">{{ mech_names.get(mech.mechanism, mech.mechanism) }}</h4>

    <div style="display: grid; grid-template-columns: 280px 280px 1fr; gap: 2rem; align-items: start;">
        <!-- Graph 1 visualization -->
        <div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.9rem;">
                <a href="/graph/{{ result.graphs[0].graph6 | urlencode }}"><code>{{ result.graphs[0].graph6 }}</code></a>
            </div>
            <div class="viz-container" style="position: relative;">
                <div id="mech-viz-{{ matrix_type }}-{{ loop.index0 }}-0" style="width: 280px; height: 280px; background: white; border-radius: 8px;"></div>
                <button class="viz-reset-btn" onclick="resetMechViz('{{ matrix_type }}', {{ loop.index0 }}, 0)" title="Reset view">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                </button>
            </div>
        </div>

        <!-- Graph 2 visualization -->
        <div>
            <div style="text-align: center; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.9rem;">
                <a href="/graph/{{ result.graphs[1].graph6 | urlencode }}"><code>{{ result.graphs[1].graph6 }}</code></a>
            </div>
            <div class="viz-container" style="position: relative;">
                <div id="mech-viz-{{ matrix_type }}-{{ loop.index0 }}-1" style="width: 280px; height: 280px; background: white; border-radius: 8px;"></div>
                <button class="viz-reset-btn" onclick="resetMechViz('{{ matrix_type }}', {{ loop.index0 }}, 1)" title="Reset view">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                </button>
            </div>
        </div>

        <!-- Config info -->
        <div>
            {% if mech.mechanism == 'gm' %}
            <div style="margin-bottom: 1rem;">
                <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem; color: var(--pico-muted-color);">Switch set</div>
                <div style="display: flex; gap: 0.4rem; flex-wrap: wrap;">
                    {% for v in mech.config.switching_set %}
                    <span style="background: #f97316; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.9rem; font-weight: 500;">{{ v }}</span>
                    {% endfor %}
                </div>
            </div>
            <div>
                <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem; color: var(--pico-muted-color);">Partition</div>
                {% set colors = ['#3b82f6', '#10b981', '#8b5cf6', '#f59e0b'] %}
                {% for part_class in mech.config.partition %}
                {% set color = colors[loop.index0 % colors|length] %}
                <div style="display: flex; gap: 0.4rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
                    {% for v in part_class %}
                    <span style="background: {{ color }}; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.9rem; font-weight: 500;">{{ v }}</span>
                    {% endfor %}
                </div>
                {% endfor %}
            </div>
            {% endif %}
        </div>
    </div>
</div>

<script>
// Render mechanism visualizations for {{ matrix_type }} mechanism {{ loop.index0 }}
(function() {
    const graphs = {{ result.graphs | tojson }};
    const mech = {{ mech | tojson }};
    const matrixType = '{{ matrix_type }}';
    const mechIdx = {{ loop.index0 }};

    if (!window.mechVizStates) window.mechVizStates = {};

    window.resetMechViz = function(mt, mi, gi) {
        const key = `${mt}-${mi}-${gi}`;
        if (window.mechVizStates[key]) {
            window.mechVizStates[key].transform.x = 0;
            window.mechVizStates[key].transform.y = 0;
            window.mechVizStates[key].transform.k = 1;
            window.mechVizStates[key].update();
        }
    };

    // Get node colors based on mechanism
    function getNodeColors() {
        const nodeColors = {};
        const partitionColors = ['#3b82f6', '#10b981', '#8b5cf6', '#f59e0b'];

        if (mech.mechanism === 'gm') {
            mech.config.partition.forEach((partClass, classIdx) => {
                partClass.forEach(v => {
                    nodeColors[v] = {fill: partitionColors[classIdx % partitionColors.length], stroke: null, strokeWidth: 0};
                });
            });

            mech.config.switching_set.forEach(v => {
                nodeColors[v] = {fill: '#f97316', stroke: '#ea580c', strokeWidth: 3};
            });
        }

        return nodeColors;
    }

    const nodeColors = getNodeColors();

    // Render both graphs
    [0, 1].forEach(graphIdx => {
        const g = graphs[graphIdx];
        const width = 280, height = 280;
        const nodes = Array.from({length: g.n}, (_, i) => ({id: i}));
        const links = g.edges.map(([s, t]) => ({source: s, target: t}));

        const svg = d3.select(`#mech-viz-${matrixType}-${mechIdx}-${graphIdx}`)
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("cursor", "grab");

        const container = svg.append("g");

        let transform = {x: 0, y: 0, k: 1};

        function updateTransform() {
            container.attr("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
        }

        window.mechVizStates[`${matrixType}-${mechIdx}-${graphIdx}`] = { transform, update: updateTransform };

        svg.call(d3.drag()
            .on("start", () => svg.style("cursor", "grabbing"))
            .on("drag", (event) => {
                transform.x += event.dx;
                transform.y += event.dy;
                updateTransform();
            })
            .on("end", () => svg.style("cursor", "grab")));

        svg.on("wheel", (event) => {
            event.preventDefault();
            const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
            const newK = Math.max(0.2, Math.min(5, transform.k * scaleFactor));
            const [mx, my] = d3.pointer(event, svg.node());
            const dx = (mx - transform.x) * (newK / transform.k - 1);
            const dy = (my - transform.y) * (newK / transform.k - 1);
            transform.x -= dx;
            transform.y -= dy;
            transform.k = newK;
            updateTransform();
        });

        const style = getComputedStyle(document.documentElement);
        const edgeColor = style.getPropertyValue('--graph-edge-color').trim();

        const link = container.append("g")
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("stroke", edgeColor)
            .attr("stroke-width", 1.5);

        const node = container.append("g")
            .selectAll("circle")
            .data(nodes)
            .join("circle")
            .attr("r", 8)
            .attr("fill", d => nodeColors[d.id] ? nodeColors[d.id].fill : '#888')
            .attr("stroke", d => nodeColors[d.id] && nodeColors[d.id].stroke ? nodeColors[d.id].stroke : null)
            .attr("stroke-width", d => nodeColors[d.id] ? nodeColors[d.id].strokeWidth : 0)
            .style("cursor", "pointer")
            .call(d3.drag()
                .on("start", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on("drag", (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on("end", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }));

        const label = container.append("g")
            .selectAll("text")
            .data(nodes)
            .join("text")
            .text(d => d.id)
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("fill", "#fff")
            .style("pointer-events", "none");

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(50))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
    });
})();
</script>
{% endfor %}

{% endif %}
{% endfor %}
{% endif %}

{% endblock %}
